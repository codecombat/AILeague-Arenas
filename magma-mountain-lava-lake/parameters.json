{
    "original": "61dd4fbdd0727b0024fb4fc0",
    "majorVersion": 0,
    "config": {
      "extraCode": "const GREEN_ITEM = 'heal';\nconst RED_ITEM = 'speed';\nconst BLUE_ITEM = 'cooldown';\n\n\n\nconst RED = 'red';\nconst BLUE = 'blue';\nconst COLORS = [RED, BLUE];\n\n\nconst ITEM_TYPES = [GREEN_ITEM, BLUE_ITEM, RED_ITEM];\n\n({\n    setUpLevel() {\n        // this.world.mirrorPlayers = true;\n        this.heroes = [this.hero, this.hero1];\n        this.heroesByColor = {\n            [RED]: this.hero,\n            [BLUE]: this.hero1\n        };\n        this.heroes.forEach((h) => {\n            h.ref = this;\n            h.hookOnHasMoved = this.heroOnHasMoved.bind(this, h);\n            let row = Math.floor((h.pos.y) / this.step);\n            let col = Math.floor((h.pos.x) / this.step);\n            h.prevCell = {row, col};\n            h.score = 0;\n            h.addTrackedProperties(['score', 'number'], ['teamPower', 'number']);\n            h.collectRange = this.heroCollectRange;\n            h.collectRangeSquared = this.heroCollectRange * this.heroCollectRange;\n            h.maxSpeed = this.heroBaseSpeed;\n            h.health = this.heroHealth;\n            h.maxHealth = this.heroHealth;\n            h.keepTrackedProperty('health');\n            h.keepTrackedProperty('maxHealth');\n            h.rangeThang = this.getByID(`range-${h.color}`);\n            h.rangeThang.setScale(0.17 * this.heroCollectRange);\n            h.canCollect = (item) => {\n                return !h.dead && h.distanceSquared(item, false) < h.collectRangeSquared;\n            };\n  \n        });\n        this.hero.opponent = this.hero1;\n        this.hero1.opponent = this.hero;\n        this.lavaThangMap = null;\n        this.items = [];\n        this.lavaMap = [];\n        this.lavas = [];\n        this.lavaMapThangs = [];\n        for (let y = 0; y < this.maxRows; y++) {\n            this.lavaMap[y] = [];\n            this.lavaMapThangs[y] = [];\n            for (let x = 0; x < this.maxCols; x++) {\n                if (y == 0 || y == this.maxRows - 1 || x == 0 || x == this.maxCols - 1) {\n                    this.lavaMap[y][x] = 9999;\n                }\n                else {\n                    this.lavaMap[y][x] = 0;\n\n                }\n                this.lavaMapThangs[y].push(null);\n            }\n        }\n        this.hero.S = \"Red clouds above their head...\";\n        this.hero.addTrackedProperties(['S', 'string']);\n        this.hero.keepTrackedProperty('S');\n        this.hero1.S = \"Blue sky in their dreams...\";\n        this.hero1.addTrackedProperties(['S', 'string']);\n        this.hero1.keepTrackedProperty('S');\n    },\n\n    onFirstFrame() {\n        this.createItems();\n        this.setInterval(this.createItems.bind(this), this.itemInterval);\n    },\n\n    createItems() {\n        let poss = null;\n        for (let i = 0; i < 900; i++) {\n            poss = this.findItemPos();\n            if (poss) break;\n        }\n        if (!poss) return;\n        let itemType = this.world.rand.choice(ITEM_TYPES);\n        for (let i = 0; i < 2; i++) {\n            let item = this.instabuild(itemType, poss[i].x, poss[i].y);\n            item.lifespan = this.itemLifespan;\n            item.onCollect = this.itemOnCollect.bind(this, item);\n            item.type = itemType;\n            this.items.push(item);\n            if (item.type == RED_ITEM && this.hero.contextMM) {\n                let n = this.world.rand.rand2(1, 9);\n                n = n.toString();\n                let m = this.hero.contextMM['r' + n];\n                // item.hudProperties = item.hudProperties || [];\n                // item.hudProperties.push('O');\n                item['_'] = n + ': ' + m;\n                item.addTrackedProperties(['_', 'string']);\n                item.keepTrackedProperty('_');\n            }\n            \n        }\n    },\n    \n\n    findItemPos() {\n        let pos = this.pickPointFromRegion(this.rectangles.item);\n        pos = new Vector(Math.round(pos.x), Math.round(pos.y));\n        let posM = new Vector(this.maxX - pos.x, this.maxY - pos.y);\n        for (let h of this.heroes) {\n            for (let p of [pos, posM]) {\n                if (h.distanceTo(p) < 20) {\n                    return false;\n                }\n            }\n        }\n        return [pos, posM];\n    },\n\n    heroOnHasMoved(h, prevPos, newPos) {\n        let dxy;\n        if (h.pos.x < 0 || h.pos.x >= this.maxCols * this.step || h.pos.y < 0 || h.pos.y >= this.maxRows * this.step) {\n            if (h.targetPos) {\n                dxy = {x: h.targetPos.x - h.pos.x, y: h.targetPos.y - h.pos.y};\n\n            }\n            if (h.pos.x < 0 || h.pos.x >= this.maxX || h.pos.y < 0 || h.pos.y >= this.maxY) {\n                h.wasWrapped = true;\n            }\n            h.pos.x = (h.pos.x + 80) % 80;\n            h.pos.y = (h.pos.y + 68) % 68;\n            h.keepTrackedProperty('pos');\n            if (dxy) {\n                h.targetPos.x = h.pos.x + dxy.x;\n                h.targetPos.y = h.pos.y + dxy.y;\n                h.keepTrackedProperty('targetPos');\n            }\n        }\n\n        let row = Math.floor((h.pos.y) / this.step);\n        let col = Math.floor((h.pos.x) / this.step);\n        \n        if (this.lavaMap[row][col] > 0 && !this.winner && !h.jumpStart) {\n            h.takeDamage(this.lavaDamage * this.world.dt);\n        }\n        h.currentCell = {row, col};\n        if (!h.prevCell) {\n            h.prevCell = {row, col};\n        }\n        if (h.jumpStart != null && !h.jumpCell) {\n            h.jumpCell = {row: h.prevCell.row, col: h.prevCell.col};\n        }\n        if (h.prevCell.row != row || h.prevCell.col != col) {            \n            if (!h.jumpCell || (h.jumpCell.row == h.prevCell.row && h.jumpCell.col == h.prevCell.col)) {\n                let lavaLifespan = h.score * this.scoreLavaCoef + this.lavaLifespan;\n                let [fromRow, toRow] = [h.prevCell.row, h.currentCell.row];\n                let [fromCol, toCol] = [h.prevCell.col, h.currentCell.col];\n                if (h.lastDirection == 'up') {\n                    if (h.wasWrapped) {\n                        toRow += this.maxRows;\n                    }\n                    for (let r = fromRow; r < toRow; r++) {\n                        this.createLavaCell(r % this.maxRows, h.currentCell.col, lavaLifespan, h.color);\n                    }\n                }\n                else if (h.lastDirection == 'down') {\n                    if (h.wasWrapped) {\n                        toRow -= this.maxRows;\n                    }\n                    else {\n                        for (let r = fromRow; r > toRow; r--) {\n                            this.createLavaCell((r + this.maxRows) % this.maxRows, h.currentCell.col, lavaLifespan, h.color);\n                        }\n                    }\n                }\n                else if (h.lastDirection == 'right') {\n                    if (h.wasWrapped) {\n                        toCol += this.maxCols;\n                    }\n                    else {\n                        for (let c = fromCol; c < toCol; c++) {\n                            this.createLavaCell(h.currentCell.row, c % this.maxCols, lavaLifespan, h.color);\n                        }\n                    }\n                }\n                else if (h.lastDirection == 'left') {\n                    if (h.wasWrapped) {\n                        toCol -= this.maxCols;\n                    }\n                    else {\n                        for (let c = fromCol; c > toCol; c--) {\n                            this.createLavaCell(h.currentCell.row, (c + this.maxCols) % this.maxCols, lavaLifespan, h.color);\n                        }\n                    }\n                }\n            }\n            h.prevCell = {row, col};\n            h.wasWrapped = false;\n        }\n    },\n\n    createLavaCell(row, col, lifespan, color) {\n        if (row <= 0 || row >= this.maxRows - 1 || col <= 0 || col >= this.maxCols - 1) return;\n        // if (this.lavaMap[row][col] <= 0) {\n        //     // let lava = this.instabuild('lava', col * this.step + this.step / 2, row * this.step + this.step / 2);\n        //     lava.row = row;\n        //     lava.col = col;\n        //     this.lavas.push(lava);\n        // }\n        if (color == BLUE) {\n            this.lavaMap[row][col] = Math.min(this.lavaMap[row][col], -lifespan);\n        }\n        else {\n            this.lavaMap[row][col] = Math.max(this.lavaMap[row][col], lifespan);\n        }\n    },\n\n    itemOnCollect(item, hero) {\n        if (!this.winner) {\n            hero.score += this.itemScore;\n        }\n        hero.keepTrackedProperty('score');\n        if (item.type == GREEN_ITEM) {\n            hero.health = Math.min(hero.health + this.itemHealth, hero.maxHealth);\n        }\n        if (item.type == BLUE_ITEM) {\n            for (let k of Object.keys(hero.abilityCooldowns)) {\n                hero.abilityCooldowns[k] = Math.max(hero.abilityCooldowns[k] - this.itemReducingCooldown, 0);\n            }\n        }\n        if (item.type == RED_ITEM) {\n            hero.effects = hero.effects.filter(e => e.name != 'haste');\n            \n            hero.addEffect({name: 'haste', duration: this.itemSpeedRatioDuration,\n                            reverts: true, factor: this.itemSpeedRatio, targetProperty: 'maxSpeed'});\n        }\n        hero.rangeThang.effects = hero.rangeThang.effects.filter(e => e.name != 'visible');\n        hero.rangeThang.addEffect({name: 'visible', duration: 0.2, reverts: true, setTo: 0.5, targetProperty: 'alpha'});\n        hero.rangeThang.updateEffects();\n    },\n\n    checkWinners() {\n        if (this.hero.health <= 0 && this.hero1.health >= 0) {\n            this.winner = this.hero1;\n            this.hero.setAlpha(0.3);\n            this.winGoal('blue-win');\n            return true;\n        }\n        else if (this.hero.health >= 0 && this.hero1.health <= 0) {\n            this.winner = this.hero;\n            this.hero1.setAlpha(0.3);\n            this.winGoal('red-win');\n            return true;\n        }\n        if ((this.hero.health <= 0 && this.hero1.health <= 0) || this.world.age > this.maxTime) {\n            // for (let h of this.heroes) {\n            //     h.score += h.health * this.healthToScoreCoef;\n            // }\n            if (this.hero.teamPower == this.hero1.teamPower) {\n                if (this.world.rand.randf() < 0.5) {\n                    this.hero.score += 1;\n                }\n                else {\n                    this.hero1.score += 1;\n                }\n                for (let h of this.heroes) {\n                    h.teamPower = h.score + h.health * this.healthToScoreCoef;\n                    \n                    h.keepTrackedProperty('teamPower');\n                }\n            }\n            if (this.hero.teamPower > this.hero1.teamPower) {\n                this.winner = this.hero;\n                this.winGoal('red-win');\n            }\n            else {\n                this.winner = this.hero1;\n                this.winGoal('blue-win');\n            }\n        }\n        \n    },\n\n    fireballUpdate(fireball) {\n        if (fireball.pos.x < 0 || fireball.pos.x >= this.maxX ||\n                fireball.pos.y < 0 || fireball.pos.y >= this.maxY) {\n            fireball.setExists(false);\n            return;\n        }\n        let row = Math.floor((fireball.pos.y) / this.step);\n        let col = Math.floor((fireball.pos.x) / this.step);\n        fireball.currentCell = {row, col};\n        if (!fireball.prevCell) {\n            fireball.prevCell = {row, col};\n        }\n        if (fireball.prevCell.row != row || fireball.prevCell.col != col) {            \n            let [fromRow, toRow] = [fireball.prevCell.row, fireball.currentCell.row];\n            let [fromCol, toCol] = [fireball.prevCell.col, fireball.currentCell.col];\n            if (fireball.lastDirection == 'up') {\n                for (let r = fromRow; r < toRow; r++) {\n                    for (let i = -1; i <= 1; i++) {\n                        this.createLavaCell(r, fireball.currentCell.col + i, fireball.power, fireball.color);\n                    }\n                }\n            }\n            else if (fireball.lastDirection == 'down') {\n                for (let r = fromRow; r > toRow; r--) {\n                    for (let i = -1; i <= 1; i++) {\n                        this.createLavaCell(r, fireball.currentCell.col + i, fireball.power, fireball.color);\n                    }\n                }\n            }\n            else if (fireball.lastDirection == 'right') {\n                for (let c = fromCol; c < toCol; c++) {\n                    for (let i = -1; i <= 1; i++) {\n                        this.createLavaCell(fireball.currentCell.row + i, c, fireball.power, fireball.color);\n                    }\n                }\n            }\n            else if (fireball.lastDirection == 'left') {\n                for (let c = fromCol; c > toCol; c--) {\n                    for (let i = -1; i <= 1; i++) {\n                        this.createLavaCell(fireball.currentCell.row + i, c, fireball.power, fireball.color);\n                    }\n                }\n            }\n            fireball.prevCell = {row, col};\n        }\n    },\n\n    rebuildLavaField() {\n        const actualLavaMapStr = [];\n        for (let i = 0; i < this.maxRows; i++) {\n            let row = [];\n            for (let j = 0; j < this.maxCols; j++) {\n                row.push(this.detectLavaType(i, j));\n            }\n            actualLavaMapStr.push(row);\n        }\n        for (let i = 1; i < this.maxRows - 1; i++) {\n            for (let j = 1; j < this.maxCols - 1; j++) {\n                let shouldBeName = actualLavaMapStr[i][j];\n                let currentName = this.lavaMapThangs[i][j] && this.lavaMapThangs[i][j].name;\n                if (shouldBeName != currentName) {\n                    if (this.lavaMapThangs[i][j]) {\n                        this.lavaMapThangs[i][j].setExists(false);\n                        this.lavaMapThangs[i][j] = null;\n                    }\n                    if (shouldBeName) {\n                        let lava = this.instabuild(shouldBeName, j * this.step + this.step / 2, i * this.step + this.step / 2);\n                        this.lavaMapThangs[i][j] = lava;\n                        lava.name = shouldBeName;\n                    }\n                }\n            }\n        }\n        \n    },\n\n    detectLavaType(r, c) {\n        if (this.lavaMap[r][c] == 0 || r == 0 || r == this.maxRows - 1 || c == 0 || c == this.maxCols - 1) {\n            return null;\n        }\n        const sign = Math.sign(this.lavaMap[r][c]);\n        let code = \"lava\";\n        if (sign == -1) {\n            code = 'blava';\n        }\n        if (r == this.maxRows - 2 || sign == Math.sign(this.lavaMap[r + 1][c])) {\n            code += '0';\n        }\n        else {\n            code += '1';\n        }\n\n        if (c == this.maxCols - 2 || sign == Math.sign(this.lavaMap[r][c + 1])) {\n            code += '0';\n        }\n        else {\n            code += '1';\n        }\n        \n        if (r == 1 || sign == Math.sign(this.lavaMap[r - 1][c])) {\n            code += '0';\n        }\n        else {\n            code += '1';\n        }\n\n        \n        if (c == 1 || sign == Math.sign(this.lavaMap[r][c - 1])) {\n            code += '0';\n        }\n        else {\n            code += '1';\n        }\n        \n        return code;\n    },\n\n\n    update() {\n        \n        for (let h of this.heroes) {\n            h.teamPower = h.score + h.health * this.healthToScoreCoef;\n            h.teamPower = Math.round(h.teamPower * 100) / 100;\n            h.keepTrackedProperty('teamPower');\n        }\n        if (!this.winner) {\n            this.checkWinners();\n        }\n        this.items = this.items.filter(item => item.exists);\n        \n        for (let y = 1; y < this.maxRows - 1; y++) {\n            for (let x = 1; x < this.maxCols - 1; x++) {\n                if (this.lavaMap[y][x] > 0) {\n                    this.lavaMap[y][x] -= this.world.dt;\n                    if (this.lavaMap[y][x] <= 0) {\n                        this.lavaMap[y][x] = 0;\n                    }\n                }\n                if (this.lavaMap[y][x] < 0) {\n                    this.lavaMap[y][x] += this.world.dt;\n                    if (this.lavaMap[y][x] >= 0) {\n                        this.lavaMap[y][x] = 0;\n                    }\n                }\n            }\n        }\n        this.rebuildLavaField();\n    }\n});",
      "maxTime": 120,
      "step": 2,
      "maxX": 80,
      "maxY": 68,
      "maxRows": 34,
      "maxCols": 40,
      "lavaLifespan": 6,
      "lavaDamage": 10,
      "special": {
        "jump": {
          "specificCooldown": 4,
          "steps": 2
        },
        "dash": {
          "specificCooldown": 4,
          "steps": 3,
          "speedRatio": 3
        },
        "fire": {
          "specificCooldown": 12
        }
      },
      "rectangles": {
        "item": [
          {
            "x": 9,
            "y": 9
          },
          {
            "x": 59,
            "y": 37
          }
        ]
      },
      "itemLifespan": 10,
      "itemInterval": 2,
      
      
      "healthToScoreCoef": 2,
      "itemScore": 1,
      "itemReducingCooldown": 0.5,
      "heroHealth": 20,
      "heroCollectRange": 4,
      "scoreLavaCoef": 0.5,
      "i18n": {
        "-": {
          "-": "-"
        }
      },
      "itemSpeedRatioDuration": 1.5,
      "itemSpeedRatio": 1.5,
      "itemHealth": 1,
      "heroBaseSpeed": 8
    }
  }